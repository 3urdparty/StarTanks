using System;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Content;
using Microsoft.Xna.Framework.Graphics;
using MonoGameLibrary;
using MonoGameLibrary.Graphics;

namespace SpaceTanks
{
    public class HomingMissile : Projectile
    {
        private Animation _explosionAnimation;
        private bool _isExploding = false;

        // --- HOMING STATE ---
        public Tank Target { get; set; }

        // Direction/heading stored in game (pixels space). Unit vector.
        public Vector2 HeadingDir { get; private set; } = new Vector2(1, 0);

        // Heading angle in radians (MonoGame convention; adjust if your sprite points up by default).
        public float HeadingAngle { get; private set; } = 0f;

        // --- TUNABLES ---
        public float MaxTurnRateRadPerSec { get; set; } = MathF.PI * 2.0f; // 360 deg/s
        public float Thrust { get; set; } = 35f; // in "physics units" force (tune)
        public float MaxSpeed { get; set; } = 12f; // meters/sec if using Aether scale
        public float SeekStrength { get; set; } = 1.0f; // 0..1 smoothing blend

        // Optional predictive lead (good if targets move)
        public bool UseLead { get; set; } = true;
        public float LeadTime { get; set; } = 0.35f; // seconds

        public HomingMissile()
            : base()
        {
            Name = "homing-missile";
        }

        public void Initialize(ContentManager content)
        {
            TextureAtlas atlas = TextureAtlas.FromFile(content, "atlas.xml");
            _sprite = atlas.GetRegion("missile-2");
            Origin = new Vector2(_sprite.Width, _sprite.Height) * 0.5f;
            Width = _sprite.Width;
            Height = _sprite.Height;

            _explosionAnimation = atlas.GetAnimation("explosion-anim");
            _explosionAnimation.Loop = false;
        }

        public override void Update(GameTime gameTime)
        {
            base.Update(gameTime);
            float dt = (float)gameTime.ElapsedGameTime.TotalSeconds;

            if (_isExploding)
            {
                _explosionAnimation.Update(dt);
                if (_explosionAnimation.HasFinished)
                    Destroyed = true;
            }
        }

        public override void Draw(SpriteBatch spriteBatch)
        {
            if (_isExploding)
            {
                if (_explosionAnimation.CurrentFrame != null)
                {
                    _explosionAnimation.CurrentFrame.Draw(
                        spriteBatch,
                        Position,
                        Color,
                        0f,
                        new Vector2(
                            _explosionAnimation.CurrentFrame.Width * 0.5f,
                            _explosionAnimation.CurrentFrame.Height * 0.5f
                        ),
                        Vector2.One,
                        Effects,
                        LayerDepth
                    );
                }
            }
            else
            {
                _sprite.Draw(
                    spriteBatch,
                    Position,
                    Color,
                    Rotation,
                    new Vector2(_sprite.Width * 0.5f, _sprite.Height * 0.5f),
                    Vector2.One,
                    Effects,
                    LayerDepth
                );
            }
        }

        public void Explode()
        {
            if (_isExploding)
                return;
            _isExploding = true;
            _explosionAnimation.Reset();
        }

        // --- HOMING MATH HELPERS (MonoGame Vector2) ---
        private static Vector2 SafeNormalize(Vector2 v)
        {
            float len = v.Length();
            if (len < 1e-6f)
                return Vector2.Zero;
            return v / len;
        }

        private static float WrapAngle(float a)
        {
            while (a > MathF.PI)
                a -= MathF.Tau;
            while (a < -MathF.PI)
                a += MathF.Tau;
            return a;
        }

        private static float MoveTowardsAngle(float current, float target, float maxDelta)
        {
            float delta = WrapAngle(target - current);
            delta = Math.Clamp(delta, -maxDelta, maxDelta);
            return current + delta;
        }

        // This gives you the desired heading direction & angle (in screen/pixel space),
        // you call it from your physics controller each Update.
        public void ComputeDesiredHeading(
            Vector2 missilePosPx,
            Vector2 missileVelPxPerSec,
            Vector2 targetPosPx,
            Vector2 targetVelPxPerSec,
            float dt
        )
        {
            if (Target == null)
                return;

            Vector2 aimPoint = targetPosPx;

            if (UseLead)
            {
                // Simple lead: aim at future target position
                aimPoint = targetPosPx + targetVelPxPerSec * LeadTime;
            }

            Vector2 toTarget = aimPoint - missilePosPx;
            Vector2 desiredDir = SafeNormalize(toTarget);
            if (desiredDir == Vector2.Zero)
                return;

            float desiredAngle = MathF.Atan2(desiredDir.Y, desiredDir.X);

            // turn-rate limit
            HeadingAngle = MoveTowardsAngle(HeadingAngle, desiredAngle, MaxTurnRateRadPerSec * dt);

            // convert angle back to unit direction
            HeadingDir = new Vector2(MathF.Cos(HeadingAngle), MathF.Sin(HeadingAngle));

            // Optional smoothing if you want (blends old dir with new dir)
            if (SeekStrength < 1f)
            {
                HeadingDir = SafeNormalize(Vector2.Lerp(HeadingDir, desiredDir, SeekStrength));
                if (HeadingDir != Vector2.Zero)
                    HeadingAngle = MathF.Atan2(HeadingDir.Y, HeadingDir.X);
            }

            // Your sprite rotation should match heading.
            // If your sprite points "right" in texture, use HeadingAngle.
            // If it points "up", subtract PI/2 etc.
            Rotation = HeadingAngle;
        }
    }
}
