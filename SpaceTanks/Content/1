using System;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Content;
using MonoGameLibrary.Graphics;
using MonoGameLibrary;
using Microsoft.Xna.Framework.Graphics;

using System.Collections.Generic;

namespace SpaceTanks
{
    public class Tank:ICollidable
    {


  public Vector2 Position { get; set; }
    public Vector2 Velocity { get; set; } = new Vector2(0,0);
        public Vector2 Origin { get; set; } = Vector2.Zero;
        public float Width => _body.Width * Scale.X;
        public float Height => _body.Height * Scale.Y;
    public CollisionState CollisionState { get; } = new CollisionState();

        private bool _isRecoiling;
        private int _currentFrame;
        private TimeSpan _elapsed;
        private readonly ContentManager _content;
        private TextureRegion _body;
        private TextureRegion _turret;
        private TextureRegion _gun;
        private Animation _body_animation;
        private Animation _recoil_animation;

        private Vector2 _position;
        // private float Velocity.X;
        // private float Velocity.Y;
        private int _moveDirection; // -1 for left, 0 for no input, 1 for right

        private const float MaxSpeed = 2f;
        private const float Acceleration = 0.05f;
        private const float Deceleration = 0.15f;
        private const float Gravity = 0.5f; // Gravity acceleration per frame
        private const float MaxFallSpeed = 10f; // Terminal velocity

        private bool _isOnGround;

        public Color Color { get; set; } = Color.White;
        private float GunRotation { get; set; } = -MathHelper.PiOver2;
        public Vector2 Scale { get; set; } =  Vector2.One;
        public SpriteEffects Effects { get; set; } = SpriteEffects.None;
        public float LayerDepth { get; set; } = 0.0f;

        public bool IsOnGround => _isOnGround;

        private Vector2 _gunPosition => new Vector2(
            _position.X,
            _position.Y - Height/2
        );

        private float gunLength=>_gun.Width;

        private Vector2 gunTip => _gunPosition + 
          new Vector2(0, _gun.Height * 0.5f) + 
          new Vector2(
            // (float)Math.Cos(GunRotation) * gunLength,
            // (float)Math.Sin(GunRotation) * gunLength
            0, 0
        );

        private float _shootCooldown = 0f;
        private const float SHOOT_DELAY = 0.5f; // Half second between shots

        public bool IsReloading => _shootCooldown > 0f;


        public Tank(ContentManager content)
        {
            _content = content;
            _position = new Vector2(100f, 100f);
            // Velocity.X = 0f;
            // Velocity.Y = 0f;
            _moveDirection = 0;

            TextureAtlas atlas = TextureAtlas.FromFile(_content, "atlas.xml");
            _body_animation = atlas.GetAnimation("tank-green-moving");
            _body = atlas.GetRegion("tank-green-1");
            _recoil_animation = atlas.GetAnimation("recoil-anim");
            _recoil_animation.Loop = false;
            _isRecoiling = false;

            _turret = atlas.GetRegion("turret");
            _gun = atlas.GetRegion("gun");
        }

        // Centers the origin for proper rotation
        public void CenterOrigin()
        {
            Origin = new Vector2(_body.Width, _body.Height) * 0.5f;
        }

        // Set the tank's position
        public void SetPosition(Vector2 position)
        {
            _position = position;
        }

        // Move the tank left
        public void MoveLeft()
        {
            _moveDirection = -1;
        }

        // In your Tank class
public Bullet Shoot()
{
    if (IsReloading)
        return null;
    
    _shootCooldown = SHOOT_DELAY;

    // Start recoil animation
    _isRecoiling = true;
    _recoil_animation.Reset();

    Vector2 gunTip = new Vector2(
        _gunPosition.X + (float)Math.Cos(GunRotation) * gunLength,
        _gunPosition.Y + (float)Math.Sin(GunRotation) * gunLength
    );
    
    return new Bullet(_content, gunTip, GunRotation, speed: 250f);
}

        // Move the tank right
        public void MoveRight()
        {
            _moveDirection = 1;
        }

        public void RotateGunLeft(float deltaTime)
        {
            GunRotation -= MathHelper.PiOver2 * deltaTime;
            GunRotation = MathHelper.Clamp(GunRotation, -MathHelper.Pi * 7/8, -MathHelper.Pi*1/8);
        }

        public void RotateGunRight(float deltaTime)
        {
            GunRotation += MathHelper.PiOver2 * deltaTime;
            GunRotation = MathHelper.Clamp(GunRotation, -MathHelper.Pi * 7/8, -MathHelper.Pi*1/8);
        }

        public void Draw(SpriteBatch spriteBatch)

        {
            _gun.Draw(
                spriteBatch,
                _gunPosition,
                Color,
                GunRotation,
                new Vector2(0, _gun.Height * 0.5f),
                Scale,
                Effects,
                LayerDepth + 0.02f
            );


            // Draw turret
            _turret.Draw(
                spriteBatch,
                _gunPosition,
                Color,
                0,
                new Vector2(_turret.Width * 0.5f, _turret.Height * 0.5f),
                Scale,
                Effects,
                LayerDepth + 0.01f
            );
            _body.Draw(spriteBatch, _position, Color, 0f, Origin, Scale, Effects, LayerDepth);


if (_isRecoiling)
{
    TextureRegion recoilFrame = _recoil_animation.CurrentFrame;

    Vector2 gunTip = new Vector2(
        _gunPosition.X + (float)Math.Cos(GunRotation) * (gunLength + 6.0f),
        _gunPosition.Y + (float)Math.Sin(GunRotation) * (gunLength + 6.0f)
    );

    recoilFrame.Draw(
        spriteBatch,
        gunTip,
        Color.White,
        GunRotation,
        new Vector2(recoilFrame.Width * 0.5f, recoilFrame.Height * 0.5f),
        Scale,
        Effects,
        LayerDepth + 0.05f
    );
}


        }


        // Update the tank's animation and movement
        public void Update(GameTime gameTime, ProceduralWorld world)
        {
            float deltaTime = (float)gameTime.ElapsedGameTime.TotalSeconds;


            if (_shootCooldown > 0f)
            {
                _shootCooldown -= deltaTime;
            }
            // Apply horizontal acceleration or deceleration based on input
            if (_moveDirection != 0)
            {
                // Accelerate in the direction of input
                Velocity += new Vector2(0, _moveDirection * Acceleration);
            }
            else
            {
                if (Velocity.X > 0)
                {
                    Velocity -= new Vector2(Deceleration, 0);
                    if (Velocity.X < 0) 
                    Velocity = new Vector2(0, Velocity.Y);
                }
                else if (Velocity.X < 0)
                {

                    Velocity += new Vector2(Deceleration, 0);
                    Velocity.X += Deceleration;
                    if (Velocity.X > 0) Velocity.X = 0;
                }
            }

            Velocity.X = MathHelper.Clamp(Velocity.X, -MaxSpeed, MaxSpeed);

            // Apply gravity
            Velocity.Y += Gravity;
            Velocity.Y = Math.Min(Velocity.Y, MaxFallSpeed); // Cap fall speed

            // Update horizontal position
            _position.X += Velocity.X;

            // Update vertical position
            _position.Y += Velocity.Y;

            // Handle collision with world
            // HandleCollision(world);

            // Reset move direction for next frame (must be set each frame by input)
            _moveDirection = 0;

            // Update animation
            _elapsed += gameTime.ElapsedGameTime;

            if (_elapsed >= _body_animation.Delay)
            {
                _elapsed -= _body_animation.Delay;
                _currentFrame++;

                if (_currentFrame >= _body_animation.Frames.Count)
                {
                    _currentFrame = 0;
                }

                _body = _body_animation.Frames[_currentFrame];
            }

            if (_isRecoiling)
            {
                _recoil_animation.Update(deltaTime);
                if (_recoil_animation.HasFinished)
                {
                    _isRecoiling = false;
                }
            }
        }


public Rectangle GetBounds()
{
    return new Rectangle(
        (int)(_position.X - Origin.X),
        (int)(_position.Y - Origin.Y),
        (int)Width,
        (int)Height
    );
}
        // private void HandleCollision(ProceduralWorld world)
        // {
        //     Rectangle tankBounds = new Rectangle(
        //         (int)(_position.X - Origin.X),
        //         (int)(_position.Y - Origin.Y),
        //         (int)Width,
        //         (int)Height
        //     );
        //
        //     Point topLeft = world.WorldToTile(new Vector2(tankBounds.Left, tankBounds.Top));
        //     Point bottomRight = world.WorldToTile(new Vector2(tankBounds.Right, tankBounds.Bottom));
        //
        //     _isOnGround = false;
        //
        //     for (int x = topLeft.X; x <= bottomRight.X; x++)
        //     {
        //         for (int y = topLeft.Y; y <= bottomRight.Y; y++)
        //         {
        //             if (world.IsSolid(x, y))
        //             {
        //                 Rectangle tileBounds = new Rectangle(
        //                     x * world.TileSize,
        //                     y * world.TileSize,
        //                     world.TileSize,
        //                     world.TileSize
        //                 );
        //
        //                 if (tankBounds.Intersects(tileBounds))
        //                 {
        //                     // Resolve collision
        //                     ResolveCollision(tankBounds, world.GetCollisionBounds());
        //                 }
        //             }
        //         }
        //     }
        // }
        //
        // private void ResolveCollision(Rectangle tank, List<Rectangle>tile)
        // {
        //     // Calculate overlap on each axis
        //     int overlapLeft = tank.Right - tile.Left;
        //     int overlapRight = tile.Right - tank.Left;
        //     int overlapTop = tank.Bottom - tile.Top;
        //     int overlapBottom = tile.Bottom - tank.Top;
        //
        //     // Find minimum overlap
        //     int minOverlap = Math.Min(
        //         Math.Min(overlapLeft, overlapRight),
        //         Math.Min(overlapTop, overlapBottom)
        //     );
        //     Console.WriteLine( "tank"+ tank.Bottom);
        //     Console.WriteLine( "tile left"+ tile.Bottom);
        //
        //     // Push tank out on axis with least overlap
        //     if (minOverlap == overlapTop  && Velocity.Y > 0)
        //     {
        //         // Hit ground
        //         _position.Y = tile.Top - Height + Origin.Y + 1f;
        //         Velocity.Y = 0;
        //         _isOnGround = true;
        //     }
        //     else if (minOverlap == overlapBottom && Velocity.Y < 0)
        //     {
        //         // Hit ceiling
        //         _position.Y = tile.Bottom + Origin.Y;
        //         Velocity.Y = 0;
        //     }
        //     else if (minOverlap == overlapLeft)
        //     {
        //         // Hit from left
        //         _position.X = tile.Left - Width + Origin.X;
        //         Velocity.X = 0;
        //     }
        //     else if (minOverlap == overlapRight)
        //     {
        //         // Hit from right
        //         _position.X = tile.Right + Origin.X;
        //         Velocity.X = 0;
        //     }
        // }
    }
}
